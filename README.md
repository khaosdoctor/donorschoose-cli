# Donors Choose CLI

> Command line interface for listing Donors Choose proposals

## Instalation

1. Clone the repository or download the tarball
2. Unpack it
3. Run `npm install` inside the directory
4. Run `npm link` inside the directory in order to create the binary links
5. Execute `donorschoose` in your command line

You'll get this screen

[![asciicast](https://asciinema.org/a/JBdTq1EdDANVGwWMja6zsz5hE.svg)](https://asciinema.org/a/JBdTq1EdDANVGwWMja6zsz5hE)

> Tests can be run by typing `npm test`, they take a while...

## Usage

The CLI uses a local state file which is stored into the `.donorsChoose` directory. This state file is the single source of truth for the application. Along with that you can set 4 environment variables:

```
DATA_DONORSCHOOSE_APIKEY
DATA_DONORSCHOOSE_BASEAPIURI
DATA_GOOGLE_APIKEY
DATA_GOOGLE_BASEAPIURI
```

> You can also change the location of the state file by setting the `DATA_APP_CONFIGURATIONPATH` environment variable.

Which are respectively the API keys and base URIs for Donors Choose and Google Geocoding API. These values can be set once, if there's no state file set (first execution) all initial values will be retrieved from these variables.

> **Important:** After the first state change (add an user, edit, save or remove any settings) a new state file will be created. Once it happens, the state file will **not** read any other environment variables and all change in those settings must be done from within the CLI menu

### Features

In this CLI you can:

- CRUD users to be used in order to query proposals by zipcode
- Query high urgency proposals by zipcode
- Query proposals by type
- Query proposals by keyword
- Edit API keys and base URIs

Within the proposal screen you'll be able to select a proposal and see more details about it along with a map to the approximate location of that school.

### Used APIs

This CLI uses the Donors Choose API to query proposals and the Google Geocoding API in order to gather location data from the combination of coordinates and keywords so we can get a more accurate representation of where the place is.

Along with that we use the Google Maps URL builder, an open spec on how to build Google Maps URIs and show them to the users. This URL is created by querying geocoding API in order to gather the place ID and mix it with the place's name as keywords and also along with the place's coordinates.

> Both API keys for Donors Choose and Geocoding must be generated by you. Trial API keys from Donors Choose **might** not have the school's address and other sensitive data.

## Architecture

this project has been developed using an architecture I created along with a few colleagues. We called it DDSP (short for **D**omain **D**ata **S**ervices **P**resentation). This architecture is described [here](https://github.com/nxcd/developer-handbook/blob/master/Arquitetura/Arquitetura-de-CÃ³digo.md) (unfortunately it is not translated to English...) and there's a demo app [here](https://github.com/khaosdoctor/event-sourcing-demo-app).

Basically the whole idea behind this architecture is to mix the MVC architecture with DDD architecture, using the ideas behind the domain segregation of DDD along with the layers of MVC. The whole architecture is based upon 4 layers:

- ***Data Layer***: Where the communication with a data source happens, this is where database connections are made, inserts, updates and everything related to a data source is executed. This is not limited to databases, since data sources can also be API clients (like in this CLI), filesystem objects or anything where data comes from. This is the base layer, it does not consume anyone besides the **domain** layer.
- ***Presentation Layer***: This is the place where user interacts with the application. In this case, the presentation layer is a CLI. This CLI is segregated into several **interactions**, those interactions contain the script that will execute the whole user story within the application. The presentation layer is located in the highest level of the application, it communicates with the **service** layer and the **domain** layer. The presentation layer takes one or more **service** layers as parameters.
- ***Domain Layer***: Domain layers are where the main data structures are stored. This is where all the entities from the app are located, along with domain errors. This layer can be consumed by every other layer. The domain layer does not consume any other layers, it is only consumed.
- ***Service Layer***: The service layer is the glue between the **data** and the **presentation** layers. It's the part of the application that will apply business logic and will orchestrate user calls. This layer takes a **data** layer as parameter and consumes it.

> There is the `utils` layer, which is the place we put our helper codes and little functions.

> All layers can have an `errors` directory, dedicated to named errors in JS, so we can query for error types on the **presentation** layer using `instanceof`

The main advantage of using this model is that you extend and plug in new features without having to change large parts of the code, for instance, it is possible to add a new presentation layer (like, an API) without having to drop de CLI, this way we could, for example, execute the app passing a flag `--api` and then this app would be executed as an API, sharing services, data and all other layers.

## Main libraries

The app is pretty simple, it uses several small libraries such as `sugar-env` to make the code more readable and easier to understand, but it also leverages core CLI libraries. The two most important libraries in this app are the `caporal` library, which allows us to easily create CLIs, and `inquirer`, which allows us to prompt the user in a more dynamic and friendly fashion.

In order to test it, I used `sinon` to mock most of the classes and `inquirer-test` to perform integration tests by simulating the execution of the CLI's process. This lib is just a wrapper around `child_process` and `spawn`. I'm also using `mocha` as test runner and `chai` as assertion library (I really do like the native `assert` but `chai` is a bit easier to understand when reading).
